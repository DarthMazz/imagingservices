<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>矩形描画アプリ - Step 2</title>
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }

    #preview-area {
      position: relative;
      /* 子要素の基準になる */
      display: inline-block;
      margin-top: 20px;
    }

    canvas {
      position: absolute;
      /* 画像の上に重ねる */
      top: 0;
      left: 0;
      cursor: crosshair;
    }

    #target-image {
      display: block;
      max-width: 800px;
      /* 画面に収まるサイズに */
    }

    #coords {
      margin: 10px 0;
    }

    .click-marker {
      position: absolute;
      background-color: rgba(0, 0, 255, 0.7);
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 12px;
      pointer-events: none;
    }

    #drag-coords,
    #drag-start-coords {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      pointer-events: none;
      display: none;
      z-index: 1000;
    }
  </style>
</head>

<body>
  <h1>画像に矩形を描く</h1>

  <form hx-post="/upload" hx-encoding="multipart/form-data" hx-target="#preview-area">
    <input type="file" name="file" accept="image/*">
    <button type="submit">アップロード</button>
  </form>

  <div id="coords">座標: -</div>
  <div id="drag-coords"></div>
  <div id="drag-start-coords"></div>
  <div id="preview-area"></div>

  <script>
    // HTMXが要素を入れ替えた後に実行されるイベント
    document.body.addEventListener('htmx:afterSwap', function (evt) {
      initCanvas();
    });

    function initCanvas() {
      const img = document.getElementById('target-image');
      if (!img) return;

      // 画像の読み込み完了を待ってからCanvasを作成
      img.onload = function () {
        const canvas = document.createElement('canvas');
        canvas.id = 'drawing-canvas';
        canvas.width = img.clientWidth;
        canvas.height = img.clientHeight;
        document.getElementById('preview-area').appendChild(canvas);

        const ctx = canvas.getContext('2d');
        let startX, startY, isDrawing = false;

        // OCR結果の描画
        const ocrDataAttr = img.getAttribute('data-ocr');
        if (ocrDataAttr) {
          try {
            const ocrData = JSON.parse(ocrDataAttr);
            const scaleX = img.clientWidth / img.naturalWidth;
            const scaleY = img.clientHeight / img.naturalHeight;

            ctx.strokeStyle = 'lime'; // OCRの枠は明るい緑色で表示
            ctx.lineWidth = 2;

            ocrData.forEach(item => {
              const pts = item.points;
              ctx.beginPath();
              ctx.moveTo(pts[0][0] * scaleX, pts[0][1] * scaleY);
              for (let i = 1; i < pts.length; i++) {
                ctx.lineTo(pts[i][0] * scaleX, pts[i][1] * scaleY);
              }
              ctx.closePath();
              ctx.stroke();
            });
          } catch (e) {
            console.error("OCR data parse error:", e);
          }
        }

        // 矩形情報とマーカー管理
        let savedRect = null;
        let startMarker = null;
        let endMarker = null;

        function createMarker(x, y) {
          const m = document.createElement('div');
          m.className = 'click-marker';
          m.style.left = x + 'px';
          m.style.top = y + 'px';
          m.textContent = `(${x}, ${y})`;
          document.getElementById('preview-area').appendChild(m);
          return m;
        }

        canvas.onmousedown = (e) => {
          // 既存のマーカーと矩形情報をリセット
          if (startMarker) startMarker.remove();
          if (endMarker) endMarker.remove();
          startMarker = null;
          endMarker = null;
          savedRect = null;

          startX = e.offsetX;
          startY = e.offsetY;
          isDrawing = true;

          const dragCoords = document.getElementById('drag-coords');
          dragCoords.textContent = `(${startX}, ${startY})`;
          dragCoords.style.left = (e.pageX + 15) + 'px';
          dragCoords.style.top = (e.pageY + 15) + 'px';
          dragCoords.style.display = 'block';

          const startDragCoords = document.getElementById('drag-start-coords');
          startDragCoords.textContent = `(${startX}, ${startY})`;
          startDragCoords.style.left = (e.pageX + 5) + 'px';
          startDragCoords.style.top = (e.pageY + 5) + 'px';
          startDragCoords.style.display = 'block';
        };

        canvas.onmousemove = (e) => {
          const mouseX = e.offsetX;
          const mouseY = e.offsetY;

          // 座標を常に表示
          document.getElementById('coords').textContent = `座標: (${mouseX}, ${mouseY})`;

          if (isDrawing) {
            // ドラッグ中の追従座標表示
            const dragCoords = document.getElementById('drag-coords');
            dragCoords.textContent = `(${mouseX}, ${mouseY})`;
            dragCoords.style.left = (e.pageX + 15) + 'px';
            dragCoords.style.top = (e.pageY + 15) + 'px';

            // 前の描画を消して、新しい矩形を描く
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;

            const width = mouseX - startX;
            const height = mouseY - startY;
            ctx.strokeRect(startX, startY, width, height);
          } else if (savedRect) {
            // 矩形確定後: マウスが矩形内にあるか判定
            const inside = (mouseX >= savedRect.x && mouseX <= savedRect.x + savedRect.w &&
              mouseY >= savedRect.y && mouseY <= savedRect.y + savedRect.h);

            const displayStyle = inside ? 'block' : 'none';
            if (startMarker) startMarker.style.display = displayStyle;
            if (endMarker) endMarker.style.display = displayStyle;
          }
        };

        canvas.onmouseup = (e) => {
          isDrawing = false;
          document.getElementById('drag-coords').style.display = 'none';
          document.getElementById('drag-start-coords').style.display = 'none';

          const endX = e.offsetX;
          const endY = e.offsetY;

          // 矩形情報を保存（正規化）
          const x = Math.min(startX, endX);
          const y = Math.min(startY, endY);
          const w = Math.abs(endX - startX);
          const h = Math.abs(endY - startY);

          savedRect = { x, y, w, h };

          // マーカーを作成
          startMarker = createMarker(startX, startY);
          endMarker = createMarker(endX, endY);

          console.log(`矩形確定: (${startX}, ${startY}) to (${endX}, ${endY})`);
          // ここで座標を保存する準備ができる
        };
      };
    }
  </script>
</body>

</html>